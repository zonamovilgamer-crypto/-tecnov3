import logging
import random
import time
from typing import List, Optional, Tuple

from services.ai_providers import GroqService, CohereService, HuggingFaceService, GeminiService

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class HumanizedWriter:
    """
    Generates human-like content by intelligently using multiple AI providers
    with key rotation, failover, and block-based generation.
    """
    def __init__(self):
        self.providers = {}
        if GroqService().is_available:
            self.providers["groq"] = GroqService()
        if CohereService().is_available:
            self.providers["cohere"] = CohereService()
        if HuggingFaceService().is_available:
            self.providers["huggingface"] = HuggingFaceService()
        if GeminiService().is_available:
            self.providers["gemini"] = GeminiService()

        self.active_provider_names = list(self.providers.keys())
        if not self.active_provider_names:
            logger.error("No AI providers are available. Please check installations and API keys.")
            raise RuntimeError("No AI providers available to HumanizedWriter.")
        logger.info(f"HumanizedWriter initialized with active providers: {self.active_provider_names}")
    def _get_humanized_prompt(self, provider_name: str, topic: str, previous_content: str = "") -> str:
        """
        Generates a prompt optimized for human-like style for a specific provider.
        """
        base_prompt = f"Escribe un párrafo sobre '{topic}' con un estilo natural, conversacional y humano. Evita la jerga robótica o repetitiva. Asegúrate de que el texto fluya de manera orgánica y sea atractivo para un lector humano."

        if previous_content:
            base_prompt += f"\n\nConsidera el siguiente contenido ya generado para asegurar coherencia y evitar repeticiones:\n{previous_content}"

        if provider_name == "groq":
            return f"Como un escritor experimentado y conciso, redacta un párrafo que continúe la narrativa de forma fluida. {base_prompt}"
        elif provider_name == "cohere":
            return f"Con un tono elocuente y persuasivo, desarrolla una idea clave en un párrafo bien estructurado. {base_prompt}"
        elif provider_name == "huggingface":
            return f"Genera un fragmento de texto creativo y original, manteniendo un estilo accesible y amigable. {base_prompt}"
        elif provider_name == "gemini":
            return f"Escribe un párrafo informativo y bien articulado, con un toque de personalidad y profundidad. {base_prompt}"
        return base_prompt

    def _generate_block(self, topic: str, min_words: int, max_words: int, previous_content: str = "") -> Optional[str]:
        """
        Generates a single block of text using a randomly selected active provider.
        Includes automatic failover and retries.
        """
        if not self.active_provider_names:
            logger.error("No active providers available to generate content.")
            return None

        shuffled_providers = list(self.active_provider_names)
        random.shuffle(shuffled_providers) # Randomize provider order for each block

        for provider_name in shuffled_providers:
            service = self.providers[provider_name]
            if not service.is_available:
                logger.debug(f"Skipping {provider_name} as it is not available.")
                continue

            prompt = self._get_humanized_prompt(provider_name, topic, previous_content)

            logger.info(f"Attempting to generate block with {provider_name}...")

            try:
                # max_tokens is roughly 1.33 * words, so for 200 words, ~266 tokens
                generated_text = service.generate_text(prompt, max_tokens=int(max_words * 1.5))

                if generated_text:
                    words = generated_text.split()
                    if min_words <= len(words) <= max_words:
                        logger.info(f"Successfully generated block ({len(words)} words) with {provider_name}.")
                        return " ".join(words[:max_words]) # Trim to max_words if needed
                    else:
                        logger.warning(f"Generated text length ({len(words)} words) out of range [{min_words}-{max_words}] for {provider_name}. Retrying...")
                else:
                    logger.warning(f"No text generated by {provider_name}. Retrying with another provider.")
            except Exception as e:
                logger.error(f"Error generating with {provider_name}: {e}. Retrying with another provider.")

            time.sleep(random.uniform(1, 3)) # Delay between provider attempts

        logger.error("Failed to generate a text block after trying all active providers.")
        return None

    def generate_humanized_content(self, topic: str, num_blocks: int = 4, words_per_block: int = 200) -> Optional[str]:
        """
        Generates humanized content by combining multiple blocks from different AI providers.
        Ensures total length validation (800+ words for 4 blocks of 200 words).
        """
        full_content_parts: List[str] = []
        total_words = 0
        min_total_words = num_blocks * words_per_block

        logger.info(f"Starting humanized content generation for topic: '{topic}' ({num_blocks} blocks, {words_per_block} words/block).")

        for i in range(num_blocks):
            logger.info(f"Generating block {i+1}/{num_blocks}...")
            previous_content_for_context = " ".join(full_content_parts[-2:]) if full_content_parts else "" # Provide last 2 blocks for context

            block = self._generate_block(topic, int(words_per_block * 0.8), int(words_per_block * 1.2), previous_content_for_context)

            if block:
                full_content_parts.append(block)
                total_words += len(block.split())
                logger.info(f"Block {i+1} generated. Current total words: {total_words}")
            else:
                logger.error(f"Could not generate block {i+1}. Aborting content generation.")
                return None

        final_content = " ".join(full_content_parts)
        final_word_count = len(final_content.split())

        if final_word_count >= min_total_words:
            logger.info(f"Content generation complete. Total words: {final_word_count} (Target: {min_total_words}+).")
            return final_content
        else:
            logger.warning(f"Generated content ({final_word_count} words) is shorter than required ({min_total_words} words).")
            # Optionally, try to generate an additional block or expand existing ones
            return final_content
